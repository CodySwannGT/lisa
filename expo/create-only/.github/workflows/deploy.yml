# This file is managed by Lisa.
# Do not edit directly â€” changes will be overwritten on the next `lisa` run.

# This is an example deployment workflow that demonstrates the recommended pattern:
# 1. Call the release.yml workflow to create a release
# 2. Implement your custom deployment logic
# 3. Optionally run load tests for staging deployments
#
# The release.yml workflow is kept separate from deployment to allow:
# - Different deployment strategies per project (AWS, Azure, GCP, etc.)
# - Custom deployment logic without modifying the release workflow
# - Optional load testing based on environment
# - Flexibility to deploy the same release to multiple environments

name: ðŸš€ Release and Deploy

on:
  push:
    branches:
      - main
      - staging
      - dev
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - main
          - staging
          - dev

# Prevent concurrent runs of the same workflow on the same ref
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Environment setup
  determine_environment:
    name: ðŸŒ Determine Environment
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      environment: ${{ steps.env.outputs.environment }}
    steps:
      - name: ðŸ”„ Set environment
        id: env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "environment=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi

  release:
    name: ðŸ“¦ Release
    # Reference to the quality checks workflow
    uses: ./.github/workflows/release.yml
    needs: [determine_environment]
    with:
      environment: ${{ needs.determine_environment.outputs.environment }}
      release_strategy: 'standard-version'
      skip_jobs: 'test:e2e,test:unit,test:integration'
      require_approval: false
      require_signatures: false
      generate_sbom: true
      node_version: '22.21.1'
      package_manager: 'bun'
      override_blackout: true
      emergency_release: false
    secrets: inherit

  # Step 2: Deploy to AWS (Custom deployment logic)
  check_eas_setup:
    name: Check EAS Setup
    runs-on: ubuntu-latest
    needs: [determine_environment]
    outputs:
      has_eas_setup: ${{ steps.check.outputs.has_eas_setup }}
    steps:
      - id: check
        run: |
          if [[ -z "${EXPO_TOKEN}" ]]; then
            echo "has_eas_setup=false" >> $GITHUB_OUTPUT
          else
            echo "has_eas_setup=true" >> $GITHUB_OUTPUT
          fi
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}

  # Check if app.config.ts has changed
  check_app_config_changes:
    name: Check App Config Changes
    runs-on: ubuntu-latest
    needs: [determine_environment]
    outputs:
      app_config_changed: ${{ steps.check_changes.outputs.app_config_changed }}
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check if app.config.ts changed
        id: check_changes
        run: |
          if git diff --name-only HEAD^ HEAD | grep -q "app.config.ts"; then
            echo "app_config_changed=true" >> $GITHUB_OUTPUT
            echo "app.config.ts has been modified"
          else
            echo "app_config_changed=false" >> $GITHUB_OUTPUT
            echo "app.config.ts has not been modified"
          fi

  # Trigger EAS Build if needed (only runs if app.config.ts changed)
  trigger_eas_build:
    name: Trigger EAS Build
    needs: [determine_environment, check_eas_setup, check_app_config_changes]
    if: needs.check_eas_setup.outputs.has_eas_setup == 'true' && needs.check_app_config_changes.outputs.app_config_changed == 'true'
    uses: ./.github/workflows/build.yml
    with:
      environment: ${{ needs.determine_environment.outputs.environment }}
    secrets:
      EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}

  # EAS Deploy/Publish
  deploy:
    name: ðŸš€ Deploy to EAS
    runs-on: ubuntu-latest
    needs:
      [
        determine_environment,
        check_eas_setup,
        release,
        check_app_config_changes,
      ]
    # Run if EAS is set up, regardless of whether trigger_eas_build ran or was skipped
    if: |
      always() && 
      needs.check_eas_setup.outputs.has_eas_setup == 'true' &&
      needs.release.result == 'success'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }} # Use branch HEAD to include version bump from release job
      - name: ðŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.21.1'
      - name: ðŸž Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest
      - name: Setup EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}
      - name: Set Env
        run: echo "PUPPETEER_SKIP_DOWNLOAD=true" >> $GITHUB_ENV
      - name: Install dependencies
        run: bun install
      - name: Copy environment file
        uses: canastro/copy-file-action@master
        with:
          source: ".env.${{ needs.determine_environment.outputs.environment == 'main' && 'production' || needs.determine_environment.outputs.environment == 'dev' && 'development' || needs.determine_environment.outputs.environment}}"
          target: '.env'
      - name: Copy environment file for production
        if: needs.determine_environment.outputs.environment != 'main'
        uses: canastro/copy-file-action@master
        with:
          source: ".env.${{ needs.determine_environment.outputs.environment == 'dev' && 'development' || needs.determine_environment.outputs.environment }}"
          target: '.env.production'
      - name: Copy amplify file (if exists)
        run: |
          ENV="${{ needs.determine_environment.outputs.environment }}"
          if [ "$ENV" == "staging" ]; then
            SOURCE_FILE="staging.aws-exports.js"
          elif [ "$ENV" == "dev" ]; then
            SOURCE_FILE="dev.aws-exports.js"
          else
            SOURCE_FILE="prod.aws-exports.js"
          fi
          if [ -f "$SOURCE_FILE" ]; then
            cp "$SOURCE_FILE" aws-exports.js
            echo "Copied $SOURCE_FILE to aws-exports.js"
          else
            echo "Skipping: $SOURCE_FILE does not exist"
          fi
      - name: Get version for deploy message
        id: get_version
        run: |
          # Use release output version if available, otherwise read from package.json
          RELEASE_VERSION="${{ needs.release.outputs.version }}"
          if [ -n "$RELEASE_VERSION" ]; then
            echo "version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
            echo "Using release version: $RELEASE_VERSION"
          else
            PKG_VERSION=$(node -p "require('./package.json').version")
            echo "version=$PKG_VERSION" >> $GITHUB_OUTPUT
            echo "Using package.json version (promotion detected): $PKG_VERSION"
          fi
      - name: Publish update
        run: STAGE=${{ needs.determine_environment.outputs.environment == 'main' && 'production' || needs.determine_environment.outputs.environment}} NODE_OPTIONS="--max-old-space-size=8192" eas update --auto --channel=${{ needs.determine_environment.outputs.environment == 'main' && 'production' || needs.determine_environment.outputs.environment}} --message="Update to v${{ steps.get_version.outputs.version }}"
      - name: Publish preview update
        run: STAGE=${{ needs.determine_environment.outputs.environment == 'main' && 'production' || needs.determine_environment.outputs.environment}} NODE_OPTIONS="--max-old-space-size=8192" eas update --channel=${{ needs.determine_environment.outputs.environment == 'main' && 'production' || needs.determine_environment.outputs.environment}}-preview --message="Preview update v${{ steps.get_version.outputs.version }}"

      - name: ðŸ“¢ Notify on success
        run: echo "Successfully deployed version ${{ steps.get_version.outputs.version }} to ${{ needs.determine_environment.outputs.environment }}"
  create_issue_on_failure:
    name: ðŸ“Œ Create Issue on Failure
    needs: [release, deploy]
    if: ${{ always() && (needs.release.result == 'failure' || needs.deploy.result == 'failure') && !contains(github.event.head_commit.message, '[skip ci]') }}
    uses: ./.github/workflows/create-issue-on-failure.yml
    with:
      package_manager: 'bun'
      node_version: '22.21.1'
      workflow_name: 'Release and Deploy'
      failed_job: ${{ needs.release.result == 'failure' && 'release' || 'deploy' }}
    secrets: inherit
